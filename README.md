# Git Webhook Deploy for Debian / Proxmox (Docker + Cloudflareâ€‘ready)

This repository provides a small, opinionated setup for **automatic deployments via Git webhooks** on a Debian server (perfect for a Proxmox LXC).  
It supports **multiple projects**, each with its own branch, work directory and deploy script, plus optional **Cloudflare Tunnel metadata** in the config.

The core idea:

- Git push â†’ Git provider sends a webhook â†’ `webhook.js` receives it â†’ matches a project in `config/projects.json` â†’ runs that projectâ€™s `deploy.sh` with arguments.
- Environment, SSH user and project configuration are bootstrapped via interactive scripts.

---

## 1. Features

- ðŸ” **Git webhook â†’ deployment** per repo/branch.
- ðŸ“¦ **Multiple projects** in one config.
- ðŸ³ **Dockerâ€‘friendly**: deploy scripts are intended to run `docker compose build/up` etc.
- â˜ï¸ **Cloudflare Tunnel metadata** per project (subdomain, port, path, tunnel name) â€“ Cloudflare itself is managed separately.
- âš™ï¸ **Bootstrap scripts**:
  - `env-bootstrap.sh` â€“ base environment (APT tools, Docker, etc.).
  - `enable_ssh.sh` â€“ optional SSH user + sudo + docker group.
  - `init.sh` â€“ interactive wizard for webhook + projects config.
- ðŸ” **check_env.sh** â€“ sanity checks for Docker, flags, config and webhook port.
- ðŸ§  **State files with versions**:
  - `config/env_bootstrap.json`
  - `config/ssh_state.json`
  - `config/projects_state.json`  
  Used by `start.sh` to decide when to reâ€‘run steps after script changes.

---

## 2. Repository layout

Typical layout of this repo:

```text
webook_deploy_debian/
â”œâ”€ start.sh                  # main entry point
â”œâ”€ webhook.js                # Node.js webhook HTTP server
â”œâ”€ package.json              # Node.js dependencies for webhook.js
â”œâ”€ config/
â”‚  â”œâ”€ projects.example.json  # example config with placeholders
â”‚  â”œâ”€ projects.json          # real config (generated by init.sh)
â”‚  â”œâ”€ env_bootstrap.json     # env-bootstrap state (auto)
â”‚  â”œâ”€ ssh_state.json         # SSH / user state (auto)
â”‚  â””â”€ projects_state.json    # init.sh state (auto)
â””â”€ scripts/
   â”œâ”€ env-bootstrap.sh       # install tools (Docker, curl, git, node, etc.)
   â”œâ”€ enable_ssh.sh          # optional SSH user + groups setup
   â”œâ”€ init.sh                # configuration wizard (webhook + projects)
   â”œâ”€ check_env.sh           # environment & config checks
   â””â”€ deploy.template.sh     # template copied to each project as deploy.sh
```

> Only `projects.example.json` is tracked by git.  
> `projects.json` and the state files are generated on the server.

---

## 3. Quick start

### 3.1. Clone and enter

```bash
cd /opt
git clone git@github.com:ViktorNikolayevIndyn/webook_deploy_debian.git
cd webook_deploy_debian
chmod +x start.sh
```

> You should run `start.sh` as **root**, especially on a fresh LXC.

### 3.2. Run the main starter

```bash
./start.sh
```

`start.sh` will:

1. Make all `.sh` scripts in the repo executable.
2. **Environment bootstrap** â€“ offer to run `scripts/env-bootstrap.sh`.
   - On first run, it installs base tools (APT update/upgrade, Docker, curl, git, node, jq, etc.).
   - After success, it writes `config/env_bootstrap.json` with a `version` and `timestamp`.
3. **SSH setup** â€“ offer to run `scripts/enable_ssh.sh`.
   - Creates a dedicated SSH user if you wish (e.g. `webuser`).
   - Optionally adds user to `sudo` and `docker` groups.
   - Writes `config/ssh_state.json` with `version` and `timestamp`.
4. **Project & webhook config** â€“ offer to run `scripts/init.sh`.
   - Asks for webhook port/path/domain and Cloudflare data (optional).
   - For each project, asks for repo / branch / workDir / domains / tunnel name.
   - Writes `config/projects.json` and copies `deploy.template.sh` into each project folder as `deploy.sh`.
   - Writes `config/projects_state.json`.

`start.sh` also tracks **script versions**:

```bash
ENV_BOOTSTRAP_VERSION="1.0.0"
SSH_VERSION="1.0.0"
INIT_VERSION="1.0.0"
```

If you later change the logic of `env-bootstrap.sh`, `enable_ssh.sh` or `init.sh`, just bump these version strings.  
On next `./start.sh`, it will notice the mismatch and offer to reâ€‘run the step (default = **Yes** for changed versions).

---

## 4. init.sh: webhook + projects config

`init.sh` is the interactive wizard that generates `config/projects.json`.

### 4.1. Webhook config section

First, it configures **webhook**:

- `port` â€“ local port for `webhook.js` (default `4000`).
- `path` â€“ HTTP path that will receive the webhook (default `/github`).
- `secret` â€“ optional shared secret for signature verification.
- `cloudflare.enabled` â€“ Boolean flag, normally `true` if you want to expose webhook via Cloudflare.
- `cloudflare.rootDomain` â€“ e.g. `"linkify.cloud"`.
- `cloudflare.subdomain` â€“ e.g. `"webhook"` â†’ full host `webhook.linkify.cloud`.
- `cloudflare.localPort` â€“ port where the webhook server listens (same as `port`).
- `cloudflare.localPath` â€“ path on the local server (usually same as `path`).
- `cloudflare.protocol` â€“ `"http"` or `"https"` for the origin URL inside the tunnel.
- `cloudflare.tunnelName` â€“ logical name of the tunnel you use for this root domain.

Example snippet (from a generated `projects.json`):

```json
"webhook": {
  "port": 4000,
  "path": "/github",
  "secret": "",
  "cloudflare": {
    "enabled": true,
    "rootDomain": "linkify.cloud",
    "subdomain": "webhook",
    "localPort": 4000,
    "localPath": "/github",
    "protocol": "http",
    "tunnelName": "linkify.cloud"
  }
}
```

> Cloudflare itself (tunnels, DNS) is managed outside this repo; the JSON only stores metadata so you and your scripts know which tunnel/domain belongs to which project.

### 4.2. Project config section

For each **project**, `init.sh` asks:

- `name` â€“ internal name, e.g. `"linkify-dev"`.
- `gitUrl` â€“ repo URL for cloning, e.g.  
  `"git@github.com:ViktorNikolayevIndyn/linkify.git"`  
  (you can also use `https://...` but SSH is recommended).
- `branch` â€“ e.g. `"dev-branch-cloud"` or `"prod-main"`.
- `workDir` â€“ path on the server, e.g. `"/opt/linkify-dev"`.
- **`projectType`** â€“ new in v1.1:
  - `1` = Docker application (Next.js, Node.js) â†’ uses `deploy.template.sh`
  - `2` = Static files (HTML/CSS/JS) â†’ uses `deploy-static.template.sh`
- `deployScript` â€“ autoâ€‘filled: `<workDir>/deploy.sh` (copied from template).
- `deployArgs` â€“ array of extra arguments:
  - Docker projects: `["dev"]` or `["prod"]` (mode)
  - Static projects: `["3005"]` (port for Python HTTP server)
- `cloudflare` â€“ projectâ€‘specific domain mapping:
  - `rootDomain` â€“ e.g. `"linkify.cloud"`.
  - `subdomain` â€“ e.g. `"dev"` or `"app"`.
  - `localPort` â€“ internal app port (e.g. `3000`).
  - `localPath` â€“ usually `"/"`.
  - `protocol` â€“ `"http"` or `"https"`.
  - `tunnelName` â€“ which Cloudflare tunnel should serve this root domain.

Example excerpt for two projects:

```json
"projects": [
  {
    "name": "linkify-dev",
    "gitUrl": "git@github.com:ViktorNikolayevIndyn/linkify.git",
    "repo": "ViktorNikolayevIndyn/linkify",
    "branch": "dev-branch-cloud",
    "workDir": "/opt/linkify-dev",
    "deployScript": "/opt/linkify-dev/deploy.sh",
    "deployArgs": ["dev"],
    "cloudflare": {
      "enabled": true,
      "rootDomain": "linkify.cloud",
      "subdomain": "dev",
      "localPort": 3000,
      "localPath": "/",
      "protocol": "http",
      "tunnelName": "linkify.cloud"
    }
  },
  {
    "name": "linkify-prod",
    "gitUrl": "git@github.com:ViktorNikolayevIndyn/linkify.git",
    "repo": "ViktorNikolayevIndyn/linkify",
    "branch": "prod-main",
    "workDir": "/opt/linkify-prod",
    "deployScript": "/opt/linkify-prod/deploy.sh",
    "deployArgs": ["prod"],
    "cloudflare": {
      "enabled": true,
      "rootDomain": "linkify.cloud",
      "subdomain": "app",
      "localPort": 3000,
      "localPath": "/",
      "protocol": "http",
      "tunnelName": "linkify.cloud"
    }
  }
],

### 4.3. Static project example

For static HTML/CSS/JS projects:

```json
{
  "name": "staticpage",
  "gitUrl": "git@github.com:USER/staticpage.git",
  "repo": "USER/staticpage",
  "branch": "main",
  "workDir": "/opt/staticpage",
  "deployScript": "/opt/staticpage/deploy.sh",
  "deployArgs": ["3005"],
  "cloudflare": {
    "enabled": true,
    "rootDomain": "linkify.cloud",
    "subdomain": "static",
    "localPort": 3005,
    "localPath": "/",
    "protocol": "http",
    "tunnelName": "linkify.cloud"
  }
}
```

**Key differences:**
- `deployArgs: ["3005"]` - port number instead of mode
- Uses `deploy-static.template.sh` - serves files via Python HTTP server
- No Docker build/restart - just git pull + restart server
- **Deploy time: 2-5 seconds** (instant for unchanged files)

See `STATIC-DEPLOY.md` for detailed static project documentation.

---

## 5. deploy.template.sh â†’ perâ€‘project deploy.sh

`deploy.template.sh` lives under `scripts/` and is automatically copied by `init.sh` into each `workDir` as `deploy.sh`.

### Optimized deployment strategy

The template includes **intelligent change detection** to avoid unnecessary rebuilds:

```bash
#!/bin/bash
set -e

MODE="$1"           # dev / prod, comes from deployArgs

# 1) Smart git pull with change detection
BEFORE_COMMIT=$(git rev-parse HEAD)
git fetch --all
REMOTE_COMMIT=$(git rev-parse @{u})

if [ "$BEFORE_COMMIT" = "$REMOTE_COMMIT" ]; then
  echo "No changes - skipping deployment"
  exit 0
fi

git pull --ff-only
AFTER_COMMIT=$(git rev-parse HEAD)

# 2) Analyze changed files
CHANGED_FILES=$(git diff --name-only "$BEFORE_COMMIT" "$AFTER_COMMIT")

# 3) Smart rebuild decision
if echo "$CHANGED_FILES" | grep -qE '^(package.*\.json|Dockerfile)'; then
  # Critical files changed â†’ full rebuild (2-3 min)
  docker compose build app-$MODE
  docker compose up -d app-$MODE
else
  # Only code changed â†’ quick restart (5-10 sec)
  docker compose restart app-$MODE
fi
```

### Performance improvements

| Scenario | Before | After | Speedup |
|----------|--------|-------|---------|
| Code changes only | 5-7 min | **5-10 sec** | **60x** |
| package.json changed | 5-7 min | 2-3 min | 2x |
| No changes (duplicate push) | 5-7 min | **instant** | âˆž |

### Additional optimizations

See `OPTIMIZATION.md` for:
- Multi-stage Dockerfile with layer caching
- Volume mounting for hot reload in development
- .dockerignore to reduce build context
- BuildKit integration

**Quick start:**
```bash
# Optimizations are already built into deploy.template.sh
# Just use init.sh to configure new projects
```

You control your real logic â€“ the template is a starting point with best practices built-in.

---

## 6. webhook.js

`webhook.js` is a small Node.js HTTP server that:

1. Reads `config/projects.json`.
2. Starts an HTTP server on `config.webhook.port`.
3. Listens only on the path `config.webhook.path` (e.g. `/github`).
4. Optionally validates a shared `secret`.
5. Parses the JSON payload for `repository.full_name` and `ref` (e.g. `refs/heads/dev-branch-cloud`).
6. Finds a matching project: same `repo` and `branch`.
7. Spawns the projectâ€™s `deployScript` with `deployArgs`.

You run it manually:

```bash
cd /opt/webook_deploy_debian
npm install               # first time
node webhook.js
```

Or via `systemd` service, e.g.:

```ini
[Unit]
Description=Git Webhook Deploy
After=network.target

[Service]
WorkingDirectory=/opt/webook_deploy_debian
ExecStart=/usr/bin/node /opt/webook_deploy_debian/webhook.js
Restart=always
User=root

[Install]
WantedBy=multi-user.target
```

Enable:

```bash
systemctl daemon-reload
systemctl enable webhook-deploy.service
systemctl start webhook-deploy.service
```

> Webhook URL on GitHub/Gitea/GitLab would then be something like:  
> `https://webhook.linkify.cloud/github`  
> Secret must match `config.webhook.secret` (if set).

---

## 7. Cloudflare tunnel (metadata)

This repo **does not** create or manage Cloudflare tunnels for you.  
The JSON only stores metadata:

- Which rootDomain + subdomain the project is served on.
- Which local `port`/`path` the app is running on.
- Which `tunnelName` you use for that domain.

You manage the tunnel separately, e.g. with a command like:

```bash
cloudflared --config /root/.cloudflared/config-linkify.yml tunnel run
```

`config-linkify.yml` would then route:

- `dev.linkify.cloud` â†’ `http://127.0.0.1:3001`
- `app.linkify.cloud` â†’ `http://127.0.0.1:3002`
- `webhook.linkify.cloud` â†’ `http://127.0.0.1:4000/github`

Exactly how you structure the YAML is up to you; the repo just gives you **consistent metadata** in `projects.json`.

---

## 8. Environment check

Use:

```bash
./scripts/check_env.sh
# or with SSH user check:
./scripts/check_env.sh webuser
```

The script will:

- Check presence of `docker`, `cloudflared`, `node`, `curl`, `jq`.
- Check whether Docker daemon is reachable.
- Show versions and presence of:
  - `config/env_bootstrap.json`
  - `config/ssh_state.json`
  - `config/projects_state.json`
- Show webhook config and a short project summary from `projects.json`.
- Check if the webhook port is listening (using `ss` and optionally `nc`).

---

## 9. projects.example.json

`config/projects.example.json` is a **template** with placeholders like:

```json
{
  "webhook": {
    "port": 4000,
    "path": "/github",
    "secret": "<YOUR_WEBHOOK_SECRET_IF_ANY>",
    "cloudflare": {
      "enabled": true,
      "rootDomain": "<YOUR_ROOT_DOMAIN>",
      "subdomain": "webhook",
      "localPort": 4000,
      "localPath": "/github",
      "protocol": "http",
      "tunnelName": "<YOUR_TUNNEL_NAME>"
    }
  },
  "projects": [
    {
      "name": "my-app-dev",
      "gitUrl": "git@github.com:<USER>/<REPO>.git",
      "repo": "<USER>/<REPO>",
      "branch": "dev-branch",
      "workDir": "/opt/my-app-dev",
      "deployScript": "/opt/my-app-dev/deploy.sh",
      "deployArgs": ["dev"],
      "cloudflare": {
        "enabled": true,
        "rootDomain": "<YOUR_ROOT_DOMAIN>",
        "subdomain": "dev",
        "localPort": 3001,
        "localPath": "/",
        "protocol": "http",
        "tunnelName": "<YOUR_TUNNEL_NAME>"
      }
    }
  ]
}
```

You normally do **not** edit this file directly in production.  
Instead, run `scripts/init.sh` and let it generate a real `config/projects.json`.

---

## 10. Typical workflow

1. Create Proxmox LXC (Debian), enable nesting if you run Docker inside.
2. Clone this repo into `/opt/webook_deploy_debian`.
3. Run `./start.sh` as root:
   - Run `env-bootstrap.sh` to install tools.
   - Run `enable_ssh.sh` to create dedicated SSH user (optional).
   - Run `init.sh` to configure webhook + projects.
4. For each project:
   - Edit `/opt/<project-name>/deploy.sh` to fit your Docker/Next.js setup.
5. Set up Cloudflare Tunnels and DNS for your domains.
6. Start `webhook.js` (manually or via systemd).
7. Add webhooks in Git provider (URL, secret).
8. Push to the configured branches â†’ deployment is triggered automatically.

